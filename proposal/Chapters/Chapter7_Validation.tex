\chapter{Validation}

While PC2L may sound great so far, we are in desperate need of some objective measurables that can demonstrate its efficiency, scalability, and usability. The goal will be to maximize each of these three key attributes, hopefully enough that they exceed comparable measurements for competing libraries. 


\section{Performance Comparison with Sequential Equivalents}
First, we will compare PC2L data structures with their sequential equivalents in the C++ STL. We will do this through several unit tests which fill, remove, and find elements within several of PC2L's data structures. Of course, some data structures, like the \texttt{pc2l::graph} will not have an exact sequential counterpart, in which case they will be compared to any data structure with common features, or reference libraries that implement the same structures. We expect sequential data structures to beat PC2L when a smaller number of elements is inserted into a data structure, but we expected PC2L to prevail as the number of elements in a data structure grows. 

\section{Adaptivity Assessment}
Users will be able to customize  caching in PC2L such that the elements that are cached best suit the access pattern of their project. In an attempt to evaluate whether this feature is actually adaptive to different access patterns, we will test different access patterns against different feature settings. For example, we could test a sequential access pattern against sequential caching, then test a regional access pattern against sequential caching, and so on and so forth. Ideally, we expect these tests to demonstrate that PC2L offers better performance when a user specifies the access pattern for their data structure. 

\section{Scalability Measurement}
In order to ensure that PC2L works at scale, we will put it through several different tests. First of all, we will generate several believable programs that are data-intensive, and perhaps find a real application from another project. Next, we will adapt these programs to utilize PC2L data structures. Finally, we will measure how the performance of each of these programs changes as nodes, processor cores, and memory are added to a run of PC2L. If designed properly, we expect PC2L to deliver better performance with each additional resource it is given. Additionally, this sort of testing can support the development process as we can graph program performance and identify if PC2L ever runs into a performance plateau after adding any number of additional resources.

\section{Usability Measurement}
Above all, PC2L is a library designed for user consumption. Any library we make will be essentially useless outside of our lab unless we can convince real users to adopt it. This is where our measurement of usability comes in. After PC2L is fully develop, we will find both experienced and novice distributed computing developers, hand them the documentation, and have them evaluate how usable PC2L is across several different criteria. There are several different major usability metrics that come up in \cite{usability} including efficiency, effectiveness, productivity, satisfaction, learnability, safety, trustfulness, accessibility, and usefulness. While these criteria are typically used for non-technical, consumer-facing products, we can adapt some of them for our purposes
